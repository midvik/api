### API Documentation 

> trade-mate.io cryptocurrency trading platform with autotrade and copytrade functions.

![Imgur](https://i.imgur.com/Y334Jzp.png)

### ДОСТУП
On the website in Trader's Cabinet you need to generate your secrets for two modes "test" and "prod":

In test you can make integration works, and signals created in this mode wouldn't be available from other channe mode.
* `key` - looks like <channel mode>(In lowercase) + <channel id> Ex: prod156
* `secret` - Generate it in channel page

### QUERY 
Query of each request should have
* `nonce : <number>` - monotonically increasing value. Ex: `+new Date()`

### HEADERS
* `authKey : <string>` - You key
* `authSignature : <string>` - Calculated signature

### CALCULATE authSignature
1. Query params sorted alphabetically, join keys and values via ":"
3. If request has body in POST/PATCH request, then add it (stringify(body)) wrapped with ":"
4. If request has not body - "::"
5. Append secret
6. Use sha256 for resulted string and calculate digest in base64

### EXAMPLE authSignature
1. queryParams `{ nonce: 14892427427, a: 1, b: 2 }`
2. body `{ some_body: '2love' }`
3. Resulted string with body -   
`a:1:b:2:nonce:14892427427:{"some_body":"2love"}:rSfSzzNA97nNJSgc0aToSw==`
4. Resulted string without body - 
`a:1:b:2:nonce:14892427427::rSfSzzNA97nNJSgc0aToSw==`
5. Use sha256 for resulted string and calculate digest in base64

### Requests in documentation example:

# 1. getStats()
Get statistics info for channel
* `score` - calculated score of the channel
* `requestsPerMinute` - max requests limit per minute
* `requestsLastMinute` - number of requests last minute
* `signalsPerDay` - max signals per day
* `signalsLastDay` - number of created signals last day
* `maxActiveSignalsPerFeed` - max active signals per channel
* channel limits `exchanges` и `base_currencies`, 1 means 100%.
  * At the time the signal is created, the limit on this exchange and the base_currency is reduced by the amount of volume in the signal; when the signal is closed, the limit volume involved in the signal returns to the limit.
  ```javascript 
  {
      "exchanges":{
          "4":{
              "baseCurrencies":{
                  "BTC":{
                      "limitRemaining":"0.40"
                  },
                  "ETH":{
                      "limitRemaining":"1"
                  }
              }
          }
      }
  }
  ```

# 2. getExchanges()
Get list of exchanges


# 3. getSymbols()
Get list of symbols and it's `symbolId`


# 4. getSignals()
Get channel signals

Available filters in query:
* `active<bool>`
* `bought<bool>`
* `performance<str>, valid values : 'gain', 'loss'`
* `currency<bool>`
* `baseCurrency<str>`
* `exchangeId<id>`


# 5. getSignal(`signalId`)
Get signal with `signalId`

`signalId` in `query`


# 6. makeSignal()
Signal creation
Request example into example file, here are details:

> Mandatory fields in `action`:
* `amount<number>|<str>` - 0 ~ 1
  * summary amount of `buys` should be equal to summary `amount` в `takeProfits` и в `stopLoss`,
* `type<str>`

> Signal is consists of `actions`, this actions has semantics like `buys`, `takeProfits`, `stopLoss`.

* `buys<hashMap<id, action>>`
* `takeProfits<hashMap<id, action>>`
* `stopLoss<action>`,
* where:
  * `key` generated by you id `action`, 
  * `value` - `action`.
    * id - unique key in signal (can be monotonically increasing value) 

## In case of what this `action` is, it has different values:

Общая концепция:
* `price` - цена покупки/продажи, если указана то будет выставлен Лимитный ордер
* `threshold` - цена активации `action`, используется как стоп цена срабатывания `action` для выставления ордера (Стоп маркетные и стоп лимитные ордера)
  * для `buys` обязательно только при `type` == `BuyIfAbove` || `BuyIfBelow`
  * для `takeProfits` и `stopLoss`, обязательно всегда
* `trailing` - доступно только для `takeProfits` и `stopLoss`
  * для `stopLoss` c `type == StopLossTrailingSell` это относительная разница уровня стоп лосс и текущей рыночной цены, в долях единицы, положительное значение
  * для `takeProfits` с `type == TakeProfitTrailingSell` это процент трейлинга в долях единицы, 3% => 0.03 
* `ladder` - доступно только для `stopLoss`, трейлинг лесенкой

Для buys
* type == `Buy`
* type == `BuyIfAbove`, обязательно `threshold`
* type == `BuyIfBelow`, обязательно `threshold`

Для take profits
* type == `TakeProfitSell`, обязательно `threshold`
* type == `TakeProfitTrailingSell`, обязательно `threshold, trailing`

Для stop loss
* type == `StopLossSell`, обязательно `threshold`
* type == `StopLossTrailingSell`, обязательно `trailing`


# 7. updateSignal(`signalId`)
Редактирование сигнала

> Обязательные поля 
* `signalId<str>`
* `action`:
  * `amount<number>|<str>`
  * `type<str>`
  * `editMode<str>`
    * `'create'`
    * `'replace'`
    * `'remove'`
      * При использовании этого типа в обьекте больше ничего передавать не надо

В `buys`, `takeProfits`, `stopLoss` надо передавать только то что подлежит изменению.


# 8. panicSellSignal(`signalId`)
Паник селл/Закрытие сигнала

`signalId` Передается в `query`

По всем вопросам https://t.me/dobrijvecher
